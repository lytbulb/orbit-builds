{"version":3,"sources":["orbit-common.js","orbit-common/cache.js","orbit-common/lib/exceptions.js","orbit-common/main.js","orbit-common/memory-source.js","orbit-common/operation-encoder.js","orbit-common/operation-processors/related-inverse-links.js","orbit-common/schema.js","orbit-common/serializer.js","orbit-common/source.js"],"sourcesContent":["define('orbit-common', ['exports', 'orbit-common/main', 'orbit-common/cache', 'orbit-common/schema', 'orbit-common/serializer', 'orbit-common/source', 'orbit-common/memory-source', 'orbit-common/lib/exceptions'], function (exports, OC, Cache, Schema, Serializer, Source, MemorySource, exceptions) {\n\n\t'use strict';\n\n\tOC['default'].Cache = Cache['default'];\n\tOC['default'].Schema = Schema['default'];\n\tOC['default'].Serializer = Serializer['default'];\n\tOC['default'].Source = Source['default'];\n\tOC['default'].MemorySource = MemorySource['default'];\n\t// exceptions\n\tOC['default'].OperationNotAllowed = exceptions.OperationNotAllowed;\n\tOC['default'].RecordNotFoundException = exceptions.RecordNotFoundException;\n\tOC['default'].LinkNotInitializedException = exceptions.LinkNotInitializedException;\n\tOC['default'].ModelNotRegisteredException = exceptions.ModelNotRegisteredException;\n\tOC['default'].LinkNotRegisteredException = exceptions.LinkNotRegisteredException;\n\tOC['default'].RecordAlreadyExistsException = exceptions.RecordAlreadyExistsException;\n\n\texports['default'] = OC['default'];\n\n});","define('orbit-common/cache', ['exports', 'orbit-common/main', 'orbit/document', 'orbit/evented', 'orbit/operation', 'orbit/lib/objects', 'orbit-common/lib/exceptions', 'orbit/lib/eq', 'orbit/lib/deprecate', 'orbit-common/operation-encoder', 'orbit-common/operation-processors/related-inverse-links'], function (exports, OC, Document, Evented, Operation, objects, exceptions, eq, deprecate, OperationEncoder, RelatedInverseLinksProcessor) {\n\n  'use strict';\n\n  var Cache = objects.Class.extend({\n    init: function(schema, options) {\n      options = options || {};\n\n      if (options.trackRevLinks !== undefined && options.maintainRevLinks === undefined) {\n        deprecate.deprecate('Please convert usage of the Cache option `trackRevLinks` to `maintainRevLinks`.');\n        options.maintainRevLinks = options.trackRevLinks;\n      }\n\n      this.trackChanges = options.trackChanges !== undefined ? options.trackChanges : true;\n      this.maintainRevLinks = options.maintainRevLinks !== undefined ? options.maintainRevLinks : true;\n      this.maintainInverseLinks = options.maintainInverseLinks !== undefined ? options.maintainRevLinks : true;\n      this.maintainDependencies = options.maintainDependencies !== undefined ? options.maintainDependencies : true;\n\n      this._doc = new Document['default'](null, {arrayBasedPaths: true});\n\n      if (this.maintainRevLinks) {\n        this._rev = {};\n      }\n\n      this._pathsToRemove = [];\n\n      Evented['default'].extend(this);\n\n      this.schema = schema;\n      this._operationEncoder = new OperationEncoder['default'](schema);\n      for (var model in schema.models) {\n        if (schema.models.hasOwnProperty(model)) {\n          this._registerModel(model);\n        }\n      }\n\n      this._relatedInverseLinksProcessor = new RelatedInverseLinksProcessor['default'](schema, this);\n\n      // TODO - clean up listener\n      this.schema.on('modelRegistered', this._registerModel, this);\n    },\n\n    _registerModel: function(model) {\n      var modelRootPath = [model];\n      if (!this.retrieve(modelRootPath)) {\n        this._doc.add(modelRootPath, {});\n      }\n    },\n\n    reset: function(data) {\n      this._doc.reset(data);\n      this.schema.registerAllKeys(data);\n    },\n\n    /**\n     Return the size of data at a particular path\n\n     @method length\n     @param path\n     @returns {Number}\n     */\n    length: function(path) {\n      var data = this.retrieve(path);\n      if (data === null || data === undefined) {\n        return data;\n      } else if (objects.isArray(data)) {\n        return data.length;\n      } else {\n        return Object.keys(data).length;\n      }\n    },\n\n    /**\n     Return data at a particular path.\n\n     Returns `null` if the path does not exist in the document.\n\n     @method retrieve\n     @param path\n     @returns {Object}\n     */\n    retrieve: function(path) {\n      try {\n        // console.log('Cache#retrieve', path, this._doc.retrieve(path));\n        return this._doc.retrieve(path);\n      } catch(e) {\n        return undefined;\n      }\n    },\n\n    /**\n     * Retrieves a link value.  Returns a null value for empty links.\n     * For hasOne links will return a string id value of the link.\n     * For hasMany links will return an array of id values.\n     *\n     * @param  {String} type Model Type.\n     * @param  {String} id   Model ID.\n     * @param  {String} link Link Key.\n     * @return {Array|String|null}      The value of the link\n     */\n    retrieveLink: function(type, id, link) {\n      var val = this.retrieve([type, id, '__rel', link]);\n      if (val !== null && typeof val === 'object') {\n        val = Object.keys(val);\n      }\n      return val;\n    },\n\n    /**\n     * Determines if a link has been initialized\n     *\n     * @param  {String} type Model Type.\n     * @param  {String} id   Model ID.\n     * @param  {String} link Link Key.\n     * @return {Boolean}\n     */\n    isLinkInitialized: function(type, id, link){\n      var linkPath = [type, id, '__rel', link].join(\"/\");\n      var currentLinkValue = this.retrieve(linkPath);\n      return currentLinkValue !== OC['default'].LINK_NOT_INITIALIZED;\n    },\n\n\n    /**\n     Returns whether a path exists in the document.\n\n     @method exists\n     @param path\n     @returns {Boolean}\n     */\n    exists: function(path) {\n      try {\n        this._doc.retrieve(path);\n        return true;\n      } catch(e) {\n        return false;\n      }\n    },\n\n    /**\n     Transforms the document with an RFC 6902-compliant operation.\n\n     Currently limited to `add`, `remove` and `replace` operations.\n\n     Throws `PathNotFoundException` if the path does not exist in the document.\n\n     @method transform\n     @param {Object} operation\n     @param {String} operation.op Must be \"add\", \"remove\", or \"replace\"\n     @param {Array or String} operation.path Path to target location\n     @param {Object} operation.value Value to set. Required for \"add\" and \"replace\"\n     @returns {Boolean} true if operation is applied or false\n     */\n    transform: function(operation) {\n      var normalizedOperation;\n      if (operation instanceof Operation['default']) {\n        normalizedOperation = operation;\n      } else {\n        normalizedOperation = new Operation['default'](operation);\n      }\n\n      var op = normalizedOperation.op;\n      var path = normalizedOperation.path;\n      var value = normalizedOperation.value;\n      var currentValue = this.retrieve(path);\n      var _this = this;\n      var dependentOperations = [];\n      var pushOps = function(ops) {\n        if (ops) {\n          if (ops.forEach) {\n            ops.forEach(function(op) {\n              if (op) dependentOperations.push(op);\n            });\n          } else {\n            dependentOperations.push(op);\n          }\n        }\n        return dependentOperations;\n      };\n\n      var performDependentOps = function() {\n        dependentOperations.forEach(function(operation) {\n          _this.transform(operation);\n        });\n        dependentOperations = [];\n      };\n      var inverse;\n\n      // console.log('Cache#transform', op, path.join('/'), value);\n\n      if (op !== 'add' && op !== 'remove' && op !== 'replace') {\n        throw new exceptions.OperationNotAllowed('Cache#transform requires an \"add\", \"remove\" or \"replace\" operation.');\n      }\n\n      if (path.length < 2) {\n        throw new exceptions.OperationNotAllowed('Cache#transform requires an operation with a path >= 2 segments.');\n      }\n\n      if (op === 'add' || op === 'replace') {\n        if (!this.exists(path.slice(0, path.length - 1))) {\n          return false;\n        }\n\n      } else if (op === 'remove') {\n        if (this._isMarkedForRemoval(path)) {\n          // console.log('remove op not required because marked for removal', path);\n          return false;\n        }\n      }\n\n      if (eq.eq(currentValue, value)) return false;\n\n      if (this.maintainDependencies) {\n        pushOps(this._dependentOps(normalizedOperation));\n      }\n\n      if (op === 'remove' || op === 'replace') {\n        this._markForRemoval(path);\n\n        if (this.maintainInverseLinks) {\n          if (op === 'replace') {\n            pushOps(this._relatedInverseLinkOps(normalizedOperation.spawn({\n              op: 'remove',\n              path: path\n            })));\n          }\n\n          pushOps(this._relatedInverseLinkOps(normalizedOperation));\n        }\n\n        if (this.maintainRevLinks) {\n          this._removeRevLinks(path, normalizedOperation);\n        }\n      }\n\n      if (this.trackChanges) {\n        inverse = this._doc.transform(normalizedOperation, true);\n        this.emit('didTransform',\n                  normalizedOperation,\n                  inverse);\n\n      } else {\n        this._doc.transform(normalizedOperation, false);\n      }\n\n      performDependentOps();\n\n      if (op === 'remove' || op === 'replace') {\n        this._unmarkForRemoval(path);\n      }\n\n      if (op === 'add' || op === 'replace') {\n        if (this.maintainRevLinks) {\n          this._addRevLinks(path, value, normalizedOperation);\n        }\n\n        if (this.maintainInverseLinks) {\n          if (op === 'replace') {\n            pushOps(this._relatedInverseLinkOps(normalizedOperation.spawn({\n              op: 'add',\n              path: path,\n              value: value\n            })));\n\n          } else {\n            pushOps(this._relatedInverseLinkOps(normalizedOperation));\n          }\n        }\n      }\n\n      performDependentOps();\n\n      return true;\n    },\n\n    _markForRemoval: function(path) {\n      path = path.join('/');\n      // console.log('_markForRemoval', path);\n      this._pathsToRemove.push(path);\n    },\n\n    _unmarkForRemoval: function(path) {\n      path = path.join('/');\n      var i = this._pathsToRemove.indexOf(path);\n      // console.log('_unmarkForRemoval', path, i);\n      if (i > -1) this._pathsToRemove.splice(i, 1);\n    },\n\n    _isMarkedForRemoval: function(path) {\n      path = path.join('/');\n      // console.log('_isMarkedForRemoval', path);\n      return (this._pathsToRemove.indexOf(path) > -1);\n    },\n\n    _dependentOps: function(operation) {\n      var operationType = this._operationEncoder.identify(operation);\n      var operations = [];\n      if (operationType === 'removeRecord') {\n        var _this = this,\n          type = operation.path[0],\n          id = operation.path[1],\n          links = _this.schema.models[type].links;\n\n        Object.keys(links).forEach(function(link) {\n          var linkSchema = links[link];\n          if (linkSchema.dependent !== 'remove') {\n            return;\n          }\n\n          var linkValue = _this.retrieveLink(type, id, link);\n          if (linkValue) {\n            [].concat(linkValue).forEach(function(value) {\n              var dependentPath = [linkSchema.model, value];\n              if (_this.retrieve(dependentPath)) {\n                operations.push(operation.spawn({\n                  op: 'remove',\n                  path: dependentPath\n                }));\n              }\n            });\n          }\n        });\n\n      }\n\n      return operations;\n    },\n\n    _addRevLinks: function(path, value, operation) {\n      // console.log('_addRevLinks', path, value);\n      if (value) {\n        var type = path[0],\n            id = path[1],\n            operationType = this._operationEncoder.identify(operation);\n\n        switch(operationType) {\n          case 'addRecord': return this._addRecordRevLinks(type, value);\n          case 'replaceRecord': return this._addRecordRevLinks(type, value);\n          case 'addHasOne': return this._addLinkRevLink(type, id, path[3], value);\n          case 'replaceHasOne': return this._addLinkRevLink(type, id, path[3], value);\n          case 'addToHasMany': return this._addLinkRevLink(type, id, path[3], path[4]);\n          case 'addHasMany': return this._addLinkRevLink(type, id, path[3], value);\n          case 'replaceHasMany': return this._addLinkRevLink(type, id, path[3], value);\n        }\n      }\n    },\n\n    _addLinkRevLink: function(type, id, link, linkValue) {\n      var linkSchema = this.schema.linkDefinition(type, link);\n      this._addRevLink(linkSchema, type, id, link, linkValue);\n    },\n\n    _addRecordRevLinks: function(type, record) {\n      var id = record.id;\n      var linkValue;\n      var linkSchema;\n      var _this = this;\n\n      if (record.__rel) {\n        Object.keys(record.__rel).forEach(function(link) {\n          linkSchema = _this.schema.linkDefinition(type, link);\n          linkValue = record.__rel[link];\n\n          if(linkValue !== OC['default'].LINK_NOT_INITIALIZED) {\n            if (linkSchema.type === 'hasMany') {\n              Object.keys(linkValue).forEach(function(relId) {\n                _this._addRevLink(linkSchema, type, id, link, relId);\n              });\n\n            } else {\n              _this._addRevLink(linkSchema, type, id, link, linkValue);\n            }\n          }\n\n        });\n      }\n    },\n\n    _revLink: function(type, id) {\n      var revForType = this._rev[type];\n      if (revForType === undefined) {\n        revForType = this._rev[type] = {};\n      }\n      var rev = revForType[id];\n      if (rev === undefined) {\n        rev = revForType[id] = {};\n      }\n      return rev;\n    },\n\n    _addRevLink: function(linkSchema, type, id, link, value) {\n      // console.log('_addRevLink', linkSchema, type, id, link, value);\n\n      if (value && typeof value === 'string' && value !== OC['default'].LINK_NOT_INITIALIZED) {\n        var linkPath = [type, id, '__rel', link];\n        if (linkSchema.type === 'hasMany') {\n          linkPath.push(value);\n        }\n        linkPath = linkPath.join('/');\n\n        var revLink = this._revLink(linkSchema.model, value);\n        revLink[linkPath] = true;\n      }\n    },\n\n    _removeRevLinks: function(path, parentOperation) {\n      // console.log('_removeRevLinks', path);\n      var value = this.retrieve(path);\n      if (value) {\n        var type = path[0],\n            id = path[1],\n            operationType = this._operationEncoder.identify(parentOperation);\n\n        switch(operationType) {\n          case 'removeRecord': return this._removeRecordRevLinks(type, id, value, parentOperation);\n          case 'replaceRecord': return this._removeRecordRevLinks(type, id, value, parentOperation);\n          case 'removeHasOne': return this._removeLinkRevLink(type, id, path[3], path[4]);\n          case 'replaceHasOne': return this._removeLinkRevLink(type, id, path[3], path[4]);\n          case 'removeHasMany': return this._removeLinkRevLink(type, id, path[3], value);\n          case 'replaceHasMany': return this._removeLinkRevLink(type, id, path[3], value);\n          case 'removeFromHasMany': return this._removeLinkRevLink(type, id, path[3], path[4]);\n        }\n      }\n    },\n\n    _removeLinkRevLink: function(type, id, link, linkValue){\n      var linkSchema = this.schema.linkDefinition(type, link);\n      this._removeRevLink(linkSchema, type, id, link, linkValue);\n    },\n\n    _removeRecordRevLinks: function(type, id, value, parentOperation){\n      // when a whole record is removed, remove any links that reference it\n      if (this.maintainRevLinks) {\n        var _this = this;\n        var revLink = this._revLink(type, id);\n        var operation;\n        var linkSchema;\n        var linkValue;\n\n        Object.keys(revLink).forEach(function(path) {\n          path = _this._doc.deserializePath(path);\n\n          if (path.length === 4) {\n            operation = parentOperation.spawn({\n              op: 'replace',\n              path: path,\n              value: null\n            });\n          } else {\n            operation = parentOperation.spawn({\n              op: 'remove',\n              path: path\n            });\n          }\n\n          _this.transform(operation);\n        });\n\n        delete this._rev[type][id];\n      }\n\n      // when a whole record is removed, remove references corresponding to each link\n      if (value.__rel) {\n        Object.keys(value.__rel).forEach(function(link) {\n          linkSchema = _this.schema.linkDefinition(type, link);\n          linkValue = value.__rel[link];\n\n          if (linkSchema.type === 'hasMany') {\n            Object.keys(linkValue).forEach(function(v) {\n              _this._removeRevLink(linkSchema, type, id, link, v);\n            });\n\n          } else {\n            _this._removeRevLink(linkSchema, type, id, link, linkValue);\n          }\n        });\n      }\n    },\n\n    _removeRevLink: function(linkSchema, type, id, link, value) {\n      // console.log('_removeRevLink', linkSchema, type, id, link, value);\n\n      if (value && typeof value === 'string') {\n        var linkPath = [type, id, '__rel', link];\n        if (linkSchema.type === 'hasMany') {\n          linkPath.push(value);\n        }\n        linkPath = linkPath.join('/');\n\n        var revLink = this._revLink(linkSchema.model, id);\n        delete revLink[linkPath];\n      }\n    },\n\n    _relatedInverseLinkOps: function(operation){\n      return this._relatedInverseLinksProcessor.process(operation, this._pathsToRemove);\n    }\n  });\n\n  exports['default'] = Cache;\n\n});","define('orbit-common/lib/exceptions', ['exports', 'orbit/lib/exceptions'], function (exports, exceptions) {\n\n  'use strict';\n\n  var OperationNotAllowed = exceptions.Exception.extend({\n    name: 'OC.OperationNotAllowed',\n    init: function(message, operation){\n      this.operation = operation;\n      this._super(message);\n    }\n  });\n\n  var ModelNotRegisteredException = exceptions.Exception.extend({\n    name: 'OC.ModelNotRegisteredException',\n    init: function(model) {\n      this.model = model;\n      this._super('model \"' + model + '\" not found');\n    },\n  });\n\n  var LinkNotRegisteredException = exceptions.Exception.extend({\n    name: 'OC.LinkNotRegisteredException',\n    init: function(model, link) {\n      this.model = model;\n      this.link = link;\n      this._super('link \"' + model + \"#\" + link + '\" not registered');\n    },\n  });\n\n\n  var _RecordException = exceptions.Exception.extend({\n    init: function(type, record, key) {\n      this.type = type;\n      this.record = record;\n      var message = type + '/' + record;\n\n      if (key) {\n        this.key = key;\n        message += '/' + key;\n      }\n      this._super(message);\n    },\n  });\n\n  /**\n   Exception thrown when a record can not be found.\n\n   @class RecordNotFoundException\n   @namespace OC\n   @param {String} type\n   @param {Object} record\n   @constructor\n   */\n  var RecordNotFoundException = _RecordException.extend({\n    name: 'OC.RecordNotFoundException',\n  });\n\n  /**\n   Exception thrown when accessing a link that hasn't been loaded yet.\n\n   @class LinkNotFoundException\n   @namespace OC\n   @param {String} type\n   @param {String} link\n   @constructor\n   */\n  var LinkNotInitializedException = exceptions.Exception.extend({\n    name: 'OC.LinkNotInitializedException',\n    init: function(type, id, link){\n      this.type = type;\n      this.link = link;\n      this._super('link \"' + [type, id, link].join(\"/\") + '\" not loaded');\n    }\n  });\n\n  /**\n   Exception thrown when a record already exists.\n\n   @class RecordAlreadyExistsException\n   @namespace OC\n   @param {String} type\n   @param {Object} record\n   @constructor\n   */\n  var RecordAlreadyExistsException = _RecordException.extend({\n    name: 'OC.RecordAlreadyExistsException',\n  });\n\n  exports.OperationNotAllowed = OperationNotAllowed;\n  exports.RecordNotFoundException = RecordNotFoundException;\n  exports.LinkNotInitializedException = LinkNotInitializedException;\n  exports.RecordAlreadyExistsException = RecordAlreadyExistsException;\n  exports.ModelNotRegisteredException = ModelNotRegisteredException;\n  exports.LinkNotRegisteredException = LinkNotRegisteredException;\n\n});","define('orbit-common/main', ['exports'], function (exports) {\n\n\t'use strict';\n\n\t/**\n\t The Orbit Common library (namespaced `OC` by default) defines a common set of\n\t compatible sources.\n\n\t The Common library contains a base abstract class, `Source`, which supports\n\t both `Transformable` and `Requestable` interfaces. The method signatures on\n\t `Source` should be supported by other sources that want to be fully compatible\n\t with the Common library.\n\n\t @module orbit-common\n\t @main orbit-common\n\t */\n\n\t/**\n\t Namespace for Orbit Common methods and classes.\n\n\t @class OC\n\t @static\n\t */\n\tvar OC = {};\n\n\tOC.LINK_NOT_INITIALIZED = \"___link_not_initialized___\";\n\n\texports['default'] = OC;\n\n});","define('orbit-common/memory-source', ['exports', 'orbit/main', 'orbit-common/main', 'orbit/lib/assert', 'orbit/lib/objects', 'orbit-common/source', 'orbit-common/lib/exceptions'], function (exports, Orbit, OC, assert, objects, Source, exceptions) {\n\n  'use strict';\n\n  var MemorySource = Source['default'].extend({\n    init: function(schema, options) {\n      assert.assert('MemorySource requires Orbit.Promise to be defined', Orbit['default'].Promise);\n      this._super.apply(this, arguments);\n    },\n\n    /////////////////////////////////////////////////////////////////////////////\n    // Transformable interface implementation\n    /////////////////////////////////////////////////////////////////////////////\n\n    _transform: function(operation) {\n      // Transform the cache\n      // Note: the cache's didTransform event will trigger this source's\n      // didTransform event.\n      this._cache.transform(operation);\n    },\n\n    /////////////////////////////////////////////////////////////////////////////\n    // Requestable interface implementation\n    /////////////////////////////////////////////////////////////////////////////\n\n    _find: function(type, id, options) {\n      var _this = this,\n          modelSchema = this.schema.models[type],\n          pk = modelSchema.primaryKey.name,\n          result;\n\n      options = options || {};\n\n      return new Orbit['default'].Promise(function(resolve, reject) {\n        if (objects.isNone(id)) {\n          result = _this._filter.call(_this, type);\n\n        } else if (objects.isArray(id)) {\n          var res,\n              resId,\n              notFound;\n\n          result = [];\n          notFound = [];\n\n          for (var i = 0, l = id.length; i < l; i++) {\n            resId = id[i];\n\n            res = _this.retrieve([type, resId]);\n\n            if (res) {\n              result.push(res);\n            } else {\n              notFound.push(resId);\n            }\n          }\n\n          if (notFound.length > 0) {\n            result = null;\n            id = notFound;\n          }\n          else if (options.include) {\n            _this._fetchRecords(type, id, options);\n          }\n\n        } else if (id !== null && typeof id === 'object') {\n          if (id[pk]) {\n            result = _this._fetchRecord(type, id[pk], options);\n\n          } else {\n            result = _this._filter.call(_this, type, id);\n          }\n\n        } else {\n          result = _this._fetchRecord(type, id, options);\n        }\n\n        if (result) {\n          resolve(result);\n        } else {\n          reject(new exceptions.RecordNotFoundException(type, id));\n        }\n      });\n    },\n\n    _fetchRecords: function(type, ids, options) {\n      var records = [];\n\n      for (var i = 0, l = ids.length; i < l; i++) {\n        var record = this._fetchRecord(type, ids[i], options);\n        records.push(record);\n      }\n\n      return records;\n    },\n\n    _fetchRecord: function(type, id, options) {\n      var _this = this;\n      var record = this.retrieve([type, id]);\n      if (!record) throw new exceptions.RecordNotFoundException(type, id);\n\n      var include = this._parseInclude(options.include);\n\n      if (include) {\n        Object.keys(include).forEach(function(link) {\n          _this._fetchLinked(type, id, link, objects.merge(options, {include: include[link]}));\n        });\n      }\n\n      return record;\n    },\n\n    _fetchLinked: function(type, id, link, options) {\n      var linkType = this.schema.models[type].links[link].model;\n      var linkValue = this.retrieveLink(type, id, link);\n\n      if (linkValue === OC['default'].LINK_NOT_INITIALIZED) throw new exceptions.LinkNotInitializedException(type, id, link);\n      if (!linkValue) return null;\n\n      return objects.isArray(linkValue)\n             ? this._fetchRecords(linkType, linkValue, options)\n             : this._fetchRecord(linkType, linkValue, options);\n    },\n\n    _parseInclude: function(include) {\n      if (!include) return undefined;\n      if (objects.isObject(include) && !objects.isArray(include)) return include;\n      if (!objects.isArray(include)) include = [include];\n\n      var parsed = {};\n\n      include.forEach(function(inclusion) {\n        var current = parsed;\n        inclusion.split(\".\").forEach(function(link) {\n          current[link] = current[link] || {};\n          current = current[link];\n        });\n      });\n\n      return parsed;\n    },\n\n    _findLink: function(type, id, link) {\n      var _this = this;\n\n      return new Orbit['default'].Promise(function(resolve, reject) {\n        id = _this.getId(type, id);\n\n        var record = _this.retrieve([type, id]);\n        if (record) {\n          var relId;\n\n          if (record.__rel) {\n            relId = record.__rel[link];\n\n            if(relId === OC['default'].LINK_NOT_INITIALIZED) {\n              reject(new exceptions.LinkNotInitializedException(type, id, link));\n            }\n\n            if (relId) {\n              var linkDef = _this.schema.linkDefinition(type, link);\n              if (linkDef.type === 'hasMany') {\n                relId = Object.keys(relId);\n              }\n            }\n          }\n\n          resolve(relId);\n\n        } else {\n          reject(new exceptions.RecordNotFoundException(type, id));\n        }\n      });\n    },\n\n    /////////////////////////////////////////////////////////////////////////////\n    // Internals\n    /////////////////////////////////////////////////////////////////////////////\n\n    _filter: function(type, query) {\n      var all = [],\n          dataForType,\n          i,\n          prop,\n          match,\n          record;\n\n      dataForType = this.retrieve([type]);\n\n      for (i in dataForType) {\n        if (dataForType.hasOwnProperty(i)) {\n          record = dataForType[i];\n          if (query === undefined) {\n            match = true;\n          } else {\n            match = false;\n            for (prop in query) {\n              if (record[prop] === query[prop]) {\n                match = true;\n              } else {\n                match = false;\n                break;\n              }\n            }\n          }\n          if (match) all.push(record);\n        }\n      }\n      return all;\n    },\n\n    _filterOne: function(type, prop, value) {\n      var dataForType,\n          i,\n          record;\n\n      dataForType = this.retrieve([type]);\n\n      for (i in dataForType) {\n        if (dataForType.hasOwnProperty(i)) {\n          record = dataForType[i];\n          if (record[prop] === value) {\n            return record;\n          }\n        }\n      }\n    }\n  });\n\n  exports['default'] = MemorySource;\n\n});","define('orbit-common/operation-encoder', ['exports', 'orbit-common/main', 'orbit/lib/objects', 'orbit-common/lib/exceptions', 'orbit/operation'], function (exports, OC, objects, exceptions, Operation) {\n\n  'use strict';\n\n  exports['default'] = objects.Class.extend({\n    init: function(schema){\n      this._schema = schema;\n    },\n\n    identify: function(operation){\n      var op = operation.op;\n      var path = operation.path;\n      var value = operation.value;\n\n      if(['add', 'replace', 'remove'].indexOf(op) === -1) throw new exceptions.OperationNotAllowed(\"Op must be add, replace or remove (was \" + op + \")\", operation);\n\n      if(path.length < 2) throw new exceptions.OperationNotAllowed(\"Path must have at least 2 segments\");\n      if(path.length === 2) return op + \"Record\";\n      if(path.length === 3) return op + \"Attribute\";\n\n      if(path[2] === '__rel'){\n        var linkType = this._schema.linkDefinition(path[0], path[3]).type;\n\n        if(linkType === 'hasMany'){\n          if(path.length === 4){\n            if(objects.isObject(value) || value === OC['default'].LINK_NOT_INITIALIZED && ['add', 'replace'].indexOf(op) !== -1) return op + 'HasMany';\n            if(op === 'remove') return 'removeHasMany';\n          }\n          else if(path.length === 5){\n            if(op === 'add') return 'addToHasMany';\n            if(op === 'remove') return 'removeFromHasMany';\n          }\n        }\n        else if (linkType === 'hasOne'){\n          return op + 'HasOne';\n        }\n        else {\n          throw new exceptions.OperationNotAllowed(\"Only hasMany and hasOne links area supported (was \" + linkType + \")\", operation);\n        }\n      }\n\n      throw new exceptions.OperationNotAllowed(\"Invalid operation \" + operation.op + \":\" + operation.path.join(\"/\") + \":\" + operation.value);\n    },\n\n    describe: function(operation){\n      var operationType = this.identify(operation);\n      return operationType + \"::\" + operation.path.join(\"/\") + \"::\" + JSON.stringify(operation.value);\n    },\n\n    addRecordOp: function(type, id, record){\n      return new Operation['default']({op: 'add', path: [type, id], value: record});\n    },\n\n    replaceRecordOp: function(type, id, record){\n      return new Operation['default']({op: 'replace', path: [type, id], value: record});\n    },\n\n    removeRecordOp: function(type, id){\n      return new Operation['default']({op: 'remove', path: [type, id]});\n    },\n\n    replaceAttributeOp: function(type, id, attribute, value){\n      var path = [type, id, attribute];\n      return new Operation['default']({op: 'replace', path: path, value: value});\n    },\n\n    linkOp: function(op, type, id, key, value){\n      return this[op + 'LinkOp'](type, id, key, value);\n    },\n\n    addLinkOp: function(type, id, key, value) {\n      var linkType = this._schema.linkDefinition(type, key).type;\n      var path = [type, id, '__rel', key];\n      var op;\n\n      if (linkType === 'hasMany') {\n        path.push(value);\n        value = true;\n        op = 'add';\n      } else {\n        op = 'replace';\n      }\n\n      return new Operation['default']({\n        op: op,\n        path: path,\n        value: value\n      });\n    },\n\n    replaceLinkOp: function(type, id, key, value) {\n      var linkType = this._schema.linkDefinition(type, key).type;\n      var path = [type, id, '__rel', key];\n\n      if (linkType === 'hasMany' &&\n          objects.isArray(value)) {\n        var obj = {};\n        for (var i = 0, l = value.length; i < l; i++) {\n          obj[value[i]] = true;\n        }\n        value = obj;\n      }\n\n      return new Operation['default']({\n        op: 'replace',\n        path: path,\n        value: value\n      });\n    },\n\n    removeLinkOp: function(type, id, key, value) {\n      var linkType = this._schema.linkDefinition(type, key).type;\n      var path = [type, id, '__rel', key];\n      var op;\n\n      if (linkType === 'hasMany') {\n        path.push(value);\n        op = 'remove';\n      } else {\n        op = 'replace';\n        value = null;\n      }\n\n      return new Operation['default']({\n        op: op,\n        path: path,\n        value: value\n      });\n    }\n  });\n\n});","define('orbit-common/operation-processors/related-inverse-links', ['exports', 'orbit-common/main', 'orbit/lib/objects', 'orbit-common/operation-encoder'], function (exports, OC, objects, OperationEncoder) {\n\n  'use strict';\n\n  exports['default'] = objects.Class.extend({\n    init: function(schema, cache){\n      this._schema = schema;\n      this._cache = cache;\n      this._operationEncoder = new OperationEncoder['default'](schema);\n    },\n\n    process: function(operation, condemnedPaths) {\n      var _this = this;\n      condemnedPaths = condemnedPaths || [];\n      var path = operation.path;\n      var value = operation.value;\n      var type = path[0];\n      var schema = this._schema;\n      var operationType = this._operationEncoder.identify(operation);\n\n      function relatedLinkOps(linkValue, linkDef){\n        linkDef = linkDef || schema.linkDefinition(type, path[3]);\n        var op = operation.op;\n        var ignoredPaths = op === 'remove' ? condemnedPaths : [];\n        return _this._relatedLinkOps(linkDef, linkValue, path[1], operation, ignoredPaths);\n      }\n\n      function addRelatedLinksOpsForRecord(record){\n        if (!record.__rel) return;\n        var linkDef;\n        var ops = [];\n\n        Object.keys(record.__rel).forEach(function(link) {\n          linkDef = schema.linkDefinition(type, link);\n          var linkValue = record.__rel[link];\n\n          if (linkDef.inverse && linkValue !== OC['default'].LINK_NOT_INITIALIZED) {\n            var relIds = linkDef.type === 'hasMany' ? Object.keys(linkValue||{}) : linkValue;\n            var linkOps = relatedLinkOps(relIds, linkDef);\n\n            for(var i = 0; i < linkOps.length; i++){\n              ops.push(linkOps[i]);\n            }\n          }\n        });\n\n        return ops;\n      }\n\n      function removeRelatedLinksOpsForRecord(record){\n        if (!record || !record.__rel) return [];\n        var linkDef;\n        var ops = [];\n\n        Object.keys(record.__rel).forEach(function(link) {\n          linkDef = schema.linkDefinition(type, link);\n          var linkValue = record.__rel[link];\n\n          if (linkDef.inverse && linkValue !== OC['default'].LINK_NOT_INITIALIZED) {\n            var relIds = linkDef.type === 'hasMany' ? Object.keys(linkValue||{}) : linkValue;\n            var linkOps = relatedLinkOps(relIds, linkDef);\n\n            for(var i = 0; i < linkOps.length; i++){\n              ops.push(linkOps[i]);\n            }\n          }\n        });\n\n        return ops;\n      }\n\n      switch (operationType) {\n        case 'addHasOne': return relatedLinkOps(value);\n        case 'replaceHasOne': return relatedLinkOps(value);\n        case 'removeHasOne': return relatedLinkOps(this._retrieve(path));\n\n        case 'addHasMany': return relatedLinkOps(Object.keys(operation.value));\n        case 'replaceHasMany': return relatedLinkOps(Object.keys(operation.value));\n        case 'removeHasMany': return relatedLinkOps(Object.keys(this._retrieve(path)));\n        case 'addToHasMany': return relatedLinkOps(path[4]);\n        case 'removeFromHasMany': return relatedLinkOps(path[4]);\n\n        case 'addRecord': return addRelatedLinksOpsForRecord(value);\n        case 'removeRecord': return removeRelatedLinksOpsForRecord(this._retrieve(path));\n\n        default: return [];\n      }\n    },\n\n    _relatedLinkOps: function(linkDef, linkValue, value, parentOperation, ignoredPaths){\n      if(objects.isNone(linkValue)) return [];\n      var relIds = objects.isArray(linkValue) ? linkValue : [linkValue];\n      var linkOps = [];\n      var linkOp;\n\n      if (linkDef.inverse) {\n        var relatedOp = this._relatedOp(parentOperation.op, linkDef);\n        for(var i = 0; i < relIds.length; i++){\n          linkOp = this._relatedLinkOp(linkDef.model, relIds[i], linkDef.inverse, value, parentOperation, relatedOp, ignoredPaths);\n          if(linkOp) linkOps.push(linkOp);\n        }\n      }\n\n      return linkOps;\n    },\n\n    _relatedOp: function(op, linkDef){\n      var relatedLinkDef = this._schema.linkDefinition(linkDef.model, linkDef.inverse);\n      if(relatedLinkDef.type === 'hasMany' && op === 'replace') return 'add';\n      return op;\n    },\n\n    _relatedLinkOp: function(type, id, link, value, parentOperation, relatedOp, ignoredPaths){\n      if (this._retrieve([type, id])) {\n\n        if(!this._cache.isLinkInitialized(type, id, link)) return;\n\n        var operation = this._operationEncoder.linkOp(relatedOp, type, id, link, value);\n        var path = operation.path.join(\"/\");\n        var isIgnoredPath = ignoredPaths.indexOf(path) > -1;\n\n        // Apply operation only if necessary\n        if (this._retrieve(operation.path) !== operation.value && !isIgnoredPath) {\n          return parentOperation.spawn(operation);\n        }\n      }\n    },\n\n    _retrieve: function(path){\n      return this._cache.retrieve(path);\n    }\n  });\n\n});","define('orbit-common/schema', ['exports', 'orbit/lib/objects', 'orbit/lib/uuid', 'orbit-common/lib/exceptions', 'orbit/evented', 'orbit-common/main'], function (exports, objects, uuid, exceptions, Evented, OC) {\n\n  'use strict';\n\n  var Schema = objects.Class.extend({\n    init: function(options) {\n      options = options || {};\n      // model defaults\n      if (options.modelDefaults) {\n        this.modelDefaults = options.modelDefaults;\n      } else {\n        this.modelDefaults = {\n          keys: {\n            'id': {primaryKey: true, defaultValue: uuid.uuid}\n          }\n        };\n      }\n      // inflection\n      if (options.pluralize) {\n        this.pluralize = options.pluralize;\n      }\n      if (options.singularize) {\n        this.singularize = options.singularize;\n      }\n\n      Evented['default'].extend(this);\n\n      // register provided model schema\n      this.models = {};\n      if (options.models) {\n        for (var model in options.models) {\n          if (options.models.hasOwnProperty(model)) {\n            this.registerModel(model, options.models[model]);\n          }\n        }\n      }\n    },\n\n    /**\n     Registers a model's schema definition.\n\n     Emits the `modelRegistered` event upon completion.\n\n     @param {String} model      name of the model\n     @param {Object} definition model schema definition\n     */\n    registerModel: function(model, definition) {\n      var modelSchema = this._mergeModelSchemas({}, this.modelDefaults, definition);\n\n      // process key definitions\n      for (var name in modelSchema.keys) {\n        var key = modelSchema.keys[name];\n\n        key.name = name;\n\n        if (key.primaryKey) {\n          if (modelSchema.primaryKey) {\n            throw new exceptions.OperationNotAllowed('Schema can only define one primaryKey per model');\n          }\n          modelSchema.primaryKey = key;\n\n        } else {\n          key.primaryKey = false;\n\n          key.secondaryToPrimaryKeyMap = {};\n          key.primaryToSecondaryKeyMap = {};\n\n          modelSchema.secondaryKeys = modelSchema.secondaryKeys || {};\n          modelSchema.secondaryKeys[name] = key;\n        }\n\n        key.type = key.type || 'string';\n        if (key.type !== 'string') {\n          throw new exceptions.OperationNotAllowed('Model keys must be of type `\"string\"`');\n        }\n      }\n\n      // ensure every model has a valid primary key\n      if (!modelSchema.primaryKey || typeof modelSchema.primaryKey.defaultValue !== 'function') {\n        throw new exceptions.OperationNotAllowed('Model schema ID defaultValue must be a function');\n      }\n\n      this.models[model] = modelSchema;\n\n      this.emit('modelRegistered', model);\n    },\n\n    /**\n     Normalizes a record according to its type and corresponding schema\n     definition.\n\n     A record's primary key, links, and meta data will all be initialized.\n\n     A record can only be normalized once. A flag is set on the record\n     (`__normalized`) to prevent \"re-normalization\".\n\n     @param  {String} model   record type\n     @param  {Object} data    record data\n     @return {Object} normalized version of `data`\n     */\n    normalize: function(model, data, options) {\n      options = options || {};\n      if (data.__normalized) return data;\n\n      var record = data;\n\n      // set flag\n      record.__normalized = true;\n\n      // init forward links\n      record.__rel = record.__rel || {};\n\n      // init meta info\n      record.__meta = record.__meta || {};\n\n      this.initDefaults(model, record, options);\n\n      return record;\n    },\n\n    modelDefinition: function(model) {\n      var modelSchema = this.models[model];\n      if (!modelSchema) {\n        throw new exceptions.ModelNotRegisteredException(model);\n      }\n      return modelSchema;\n    },\n\n    initDefaults: function(model, record, options) {\n      options = options || {};\n      if (!record.__normalized) {\n        throw new exceptions.OperationNotAllowed('Schema.initDefaults requires a normalized record');\n      }\n\n      var modelSchema = this.modelDefinition(model),\n          keys = modelSchema.keys,\n          attributes = modelSchema.attributes,\n          links = modelSchema.links;\n\n      // init primary key - potentially setting the primary key from secondary keys if necessary\n      this._initPrimaryKey(modelSchema, record);\n\n      // init default key values\n      for (var key in keys) {\n        if (record[key] === undefined) {\n          record[key] = this._defaultValue(record, keys[key].defaultValue, null);\n        }\n      }\n\n      // init default attribute values\n      if (attributes) {\n        for (var attribute in attributes) {\n          if (record[attribute] === undefined) {\n            record[attribute] = this._defaultValue(record, attributes[attribute].defaultValue, null);\n          }\n        }\n      }\n\n      // init default link values\n      if (links) {\n        for (var link in links) {\n          if (record.__rel[link] === undefined) {\n            if(options.initializeLinks !== false){\n              record.__rel[link] = this._defaultValue(record,\n                                                      links[link].defaultValue,\n                                                      links[link].type === 'hasMany' ? {} : null);\n            }\n            else {\n              record.__rel[link] = OC['default'].LINK_NOT_INITIALIZED;\n            }\n          }\n        }\n      }\n\n      this._mapKeys(modelSchema, record);\n    },\n\n    primaryToSecondaryKey: function(model, secondaryKeyName, primaryKeyValue, autoGenerate) {\n      var modelSchema = this.modelDefinition(model);\n      var secondaryKey = modelSchema.keys[secondaryKeyName];\n\n      var value = secondaryKey.primaryToSecondaryKeyMap[primaryKeyValue];\n\n      // auto-generate secondary key if necessary, requested, and possible\n      if (value === undefined && autoGenerate && secondaryKey.defaultValue) {\n        value = secondaryKey.defaultValue();\n        this._registerKeyMapping(secondaryKey, primaryKeyValue, value);\n      }\n\n      return value;\n    },\n\n    secondaryToPrimaryKey: function(model, secondaryKeyName, secondaryKeyValue, autoGenerate) {\n      var modelSchema = this.modelDefinition(model);\n      var secondaryKey = modelSchema.keys[secondaryKeyName];\n\n      var value = secondaryKey.secondaryToPrimaryKeyMap[secondaryKeyValue];\n\n      // auto-generate primary key if necessary, requested, and possible\n      if (value === undefined && autoGenerate && modelSchema.primaryKey.defaultValue) {\n        value = modelSchema.primaryKey.defaultValue();\n        this._registerKeyMapping(secondaryKey, value, secondaryKeyValue);\n      }\n\n      return value;\n    },\n\n    /**\n     Given a data object structured according to this schema, register all of its\n     primary and secondary key mappings. This data object may contain any number\n     of records and types.\n\n     @param {Object} data - data structured according to this schema\n     */\n    registerAllKeys: function(data) {\n      if (data) {\n        Object.keys(data).forEach(function(type) {\n          var modelSchema = this.modelDefinition(type);\n\n          if (modelSchema && modelSchema.secondaryKeys) {\n            var records = data[type];\n\n            Object.keys(records).forEach(function(id) {\n              var record = records[id];\n              var altId;\n\n              Object.keys(modelSchema.secondaryKeys).forEach(function(secondaryKey) {\n                altId = record[secondaryKey];\n                if (altId !== undefined && altId !== null) {\n                  var secondaryKeyDef = modelSchema.secondaryKeys[secondaryKey];\n                  this._registerKeyMapping(secondaryKeyDef, id, altId);\n                }\n              }, this);\n            }, this);\n          }\n        }, this);\n      }\n    },\n\n    /**\n     A naive pluralization method.\n\n     Override with a more robust general purpose inflector or provide an\n     inflector tailored to the vocabularly of your application.\n\n     @param  {String} word\n     @return {String} plural form of `word`\n     */\n    pluralize: function(word) {\n      return word + 's';\n    },\n\n    /**\n     A naive singularization method.\n\n     Override with a more robust general purpose inflector or provide an\n     inflector tailored to the vocabularly of your application.\n\n     @param  {String} word\n     @return {String} singular form of `word`\n     */\n    singularize: function(word) {\n      if (word.lastIndexOf('s') === word.length - 1) {\n        return word.substr(0, word.length - 1);\n      } else {\n        return word;\n      }\n    },\n\n    linkDefinition: function(type, link){\n      var model = this.modelDefinition(type);\n\n      var linkProperties = model.links[link];\n      if(!linkProperties) throw new exceptions.LinkNotRegisteredException(type, link);\n\n      return linkProperties;\n    },\n\n    _defaultValue: function(record, value, defaultValue) {\n      if (value === undefined) {\n        return defaultValue;\n\n      } else if (typeof value === 'function') {\n        return value.call(record);\n\n      } else {\n        return value;\n      }\n    },\n\n    _initPrimaryKey: function(modelSchema, record) {\n      var pk = modelSchema.primaryKey.name;\n      var id = record[pk];\n\n      // init primary key from secondary keys\n      if (!id && modelSchema.secondaryKeys) {\n        var keyNames = Object.keys(modelSchema.secondaryKeys);\n        for (var i=0, l = keyNames.length; i <l ; i++){\n          var key = modelSchema.keys[keyNames[i]];\n          var value = record[key.name];\n          if (value) {\n            id = key.secondaryToPrimaryKeyMap[value];\n            if (id) {\n              record[pk] = id;\n              return;\n            }\n          }\n        }\n      }\n    },\n\n    _mapKeys: function(modelSchema, record) {\n      var id = record[modelSchema.primaryKey.name];\n\n      if (modelSchema.secondaryKeys) {\n        Object.keys(modelSchema.secondaryKeys).forEach(function(name) {\n          var value = record[name];\n          if (value) {\n            var key = modelSchema.secondaryKeys[name];\n            this._registerKeyMapping(key, id, value);\n          }\n        }, this);\n      }\n    },\n\n    _registerKeyMapping: function(secondaryKeyDef, primaryValue, secondaryValue) {\n      secondaryKeyDef.primaryToSecondaryKeyMap[primaryValue] = secondaryValue;\n      secondaryKeyDef.secondaryToPrimaryKeyMap[secondaryValue] = primaryValue;\n    },\n\n    _mergeModelSchemas: function(base) {\n      var sources = Array.prototype.slice.call(arguments, 1);\n\n      // ensure model schema has categories set\n      base.keys = base.keys || {};\n      base.attributes = base.attributes || {};\n      base.links = base.links || {};\n\n      sources.forEach(function(source) {\n        source = objects.clone(source);\n        this._mergeModelFields(base.keys, source.keys);\n        this._mergeModelFields(base.attributes, source.attributes);\n        this._mergeModelFields(base.links, source.links);\n      }, this);\n\n      return base;\n    },\n\n    _mergeModelFields: function(base, source) {\n      if (source) {\n        Object.keys(source).forEach(function(field) {\n          if (source.hasOwnProperty(field)) {\n            var fieldDef = source[field];\n            if (fieldDef) {\n              base[field] = fieldDef;\n            } else {\n              // fields defined as falsey should be removed\n              delete base[field];\n            }\n          }\n        });\n      }\n    }\n  });\n\n  exports['default'] = Schema;\n\n});","define('orbit-common/serializer', ['exports', 'orbit/lib/objects', 'orbit/lib/stubs'], function (exports, objects, stubs) {\n\n  'use strict';\n\n  var Serializer = objects.Class.extend({\n    init: function(schema) {\n      this.schema = schema;\n    },\n\n    serialize: stubs.required,\n\n    deserialize: stubs.required\n  });\n\n  exports['default'] = Serializer;\n\n});","define('orbit-common/source', ['exports', 'orbit/main', 'orbit-common/main', 'orbit/document', 'orbit/transformable', 'orbit/requestable', 'orbit/lib/assert', 'orbit/lib/stubs', 'orbit/lib/objects', 'orbit-common/cache', 'orbit/operation', 'orbit-common/lib/exceptions', 'orbit-common/operation-encoder'], function (exports, Orbit, OC, Document, Transformable, Requestable, assert, stubs, objects, Cache, Operation, exceptions, OperationEncoder) {\n\n  'use strict';\n\n  var Source = objects.Class.extend({\n    init: function(schema, options) {\n      assert.assert(\"Source's `schema` must be specified\", schema);\n\n      this.schema = schema;\n\n      options = options || {};\n\n      // Create an internal cache and expose some elements of its interface\n      this._cache = new Cache['default'](schema);\n      objects.expose(this, this._cache, 'length', 'reset', 'retrieve', 'retrieveLink');\n\n      this._operationEncoder = new OperationEncoder['default'](schema);\n\n      // TODO - clean up listener\n      this._cache.on('didTransform', this._cacheDidTransform, this);\n\n      Transformable['default'].extend(this);\n      Requestable['default'].extend(this, ['find', 'add', 'update', 'patch', 'remove',\n                                'findLink', 'addLink', 'removeLink', 'updateLink',\n                                'findLinked']);\n\n      Source.created(this);\n    },\n\n    /////////////////////////////////////////////////////////////////////////////\n    // Transformable interface implementation\n    /////////////////////////////////////////////////////////////////////////////\n\n    /**\n     Internal method that applies a single transform to this source.\n\n     `_transform` must be implemented by a `Transformable` source.\n     It is called by the public method `transform` in order to actually apply\n     transforms.\n\n     `_transform` should return a promise if the operation is asynchronous.\n\n     @method _transform\n     @param operation JSON PATCH operation as detailed in RFC 6902\n     @private\n     */\n    _transform: stubs.required,\n\n    /////////////////////////////////////////////////////////////////////////////\n    // Requestable interface implementation\n    /////////////////////////////////////////////////////////////////////////////\n\n    _find: stubs.required,\n\n    _findLink: stubs.required,\n\n    _findLinked: function(type, id, link, options){\n      var modelId = this.getId(type, id);\n      var linkType = this.schema.linkDefinition(type, link).model;\n      var linkValue = this.retrieveLink(type, modelId, link);\n\n      if (linkValue === OC['default'].LINK_NOT_INITIALIZED) throw new exceptions.LinkNotInitializedException(type, id, link);\n      if (!linkValue) return null;\n\n      return this._find(linkType, linkValue, options);\n    },\n\n    _add: function(type, data) {\n      data = data || {};\n\n      var record = this.normalize(type, data);\n\n      var id = this.getId(type, record),\n          path = [type, id],\n          _this = this;\n\n      return this.transform(this._operationEncoder.addRecordOp(type, id, record)).then(function() {\n        return _this.retrieve(path);\n      });\n    },\n\n    _update: function(type, data) {\n      var record = this.normalize(type, data);\n      var id = this.getId(type, record);\n\n      return this.transform(this._operationEncoder.replaceRecordOp(type, id, record));\n    },\n\n    _patch: function(type, id, attribute, value) {\n      id = this._normalizeId(type, id);\n      // todo - confirm this simplification is valid (i.e. don't attempt to deserialize attribute path)\n      return this.transform(this._operationEncoder.replaceAttributeOp(type, id, attribute, value));\n    },\n\n    _remove: function(type, id) {\n      id = this._normalizeId(type, id);\n      return this.transform(this._operationEncoder.removeRecordOp(type, id));\n    },\n\n    _addLink: function(type, id, key, value) {\n      id = this._normalizeId(type, id);\n      value = this._normalizeLink(type, key, value);\n\n      this._confirmLinkIsInitialized(type, id, key);\n\n      return this.transform(this._operationEncoder.addLinkOp(type, id, key, value));\n    },\n\n    _removeLink: function(type, id, key, value) {\n      id = this._normalizeId(type, id);\n      value = this._normalizeLink(type, key, value);\n\n      this._confirmLinkIsInitialized(type, id, key);\n\n      return this.transform(this._operationEncoder.removeLinkOp(type, id, key, value));\n    },\n\n    _updateLink: function(type, id, key, value) {\n      var linkDef = this.schema.models[type].links[key];\n\n      assert.assert('hasMany links can only be replaced when flagged as `actsAsSet`',\n             linkDef.type !== 'hasMany' || linkDef.actsAsSet);\n\n      this._confirmLinkIsInitialized(type, id, key);\n\n      id = this._normalizeId(type, id);\n      value = this._normalizeLink(type, key, value);\n\n      var op = this._operationEncoder.replaceLinkOp(type, id, key, value);\n      return this.transform(op);\n    },\n\n    /////////////////////////////////////////////////////////////////////////////\n    // Event handlers\n    /////////////////////////////////////////////////////////////////////////////\n\n    _cacheDidTransform: function(operation, inverse) {\n      this.didTransform(operation, inverse);\n    },\n\n    /////////////////////////////////////////////////////////////////////////////\n    // Helpers\n    /////////////////////////////////////////////////////////////////////////////\n\n    _normalizeId: function(type, id) {\n      if (objects.isObject(id)) {\n        var record = this.normalize(type, id);\n        id = this.getId(type, record);\n      }\n      return id;\n    },\n\n    _normalizeLink: function(type, key, value) {\n      if (objects.isObject(value)) {\n        var linkDef = this.schema.models[type].links[key];\n        var relatedRecord;\n\n        if (objects.isArray(value)) {\n          for (var i = 0, l = value.length; i < l; i++) {\n            if (objects.isObject(value[i])) {\n              relatedRecord = this.normalize(linkDef.model, value[i]);\n              value[i] = this.getId(linkDef.model, relatedRecord);\n            }\n          }\n\n        } else {\n          relatedRecord = this.normalize(linkDef.model, value);\n          value = this.getId(linkDef.model, relatedRecord);\n        }\n      }\n      return value;\n    },\n\n    normalize: function(type, data) {\n      return this.schema.normalize(type, data);\n    },\n\n    initDefaults: function(type, record) {\n      return this.schema.initDefaults(type, record);\n    },\n\n    getId: function(type, data) {\n      if (objects.isObject(data)) {\n        return data[this.schema.models[type].primaryKey.name];\n      } else {\n        return data;\n      }\n    },\n\n    /////////////////////////////////////////////////////////////////////////////\n    // Internals\n    /////////////////////////////////////////////////////////////////////////////\n\n    _isLinkEmpty: function(linkType, linkValue) {\n      return (linkType === 'hasMany' && linkValue && linkValue.length === 0 ||\n              linkType === 'hasOne' && objects.isNone(linkValue));\n    },\n\n    _confirmLinkIsInitialized: function(type, id, link){\n      id = this.getId(type, id);\n      var linkValue = this.retrieveLink(type, id, link);\n\n      if(linkValue === OC['default'].LINK_NOT_INITIALIZED) throw new exceptions.LinkNotInitializedException(type, id, link);\n    }\n  });\n\n  /**\n   * A place to track the creation of any Source, is called in the Source init\n   * method.  The source might not be fully configured / setup by the time you\n   * receive it, but we provide this hook for potential debugging tools to monitor\n   * all sources.\n   *\n   * @namespace OC\n   * @param {OC.Source} source The newly forged Source.\n   */\n  Source.created = function(/* source */) {};\n\n  exports['default'] = Source;\n\n});"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9WA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;","file":"orbit-common.amd.js"}